// Implementation file for sequence4.h

#include <cassert>
#include <cstdlib>
#include "node2.h"
#include "sequence4.h"

namespace CISP430_A3
{
	template <class Item>
	sequence<Item>::sequence()
		// Uses cstdlib.
	{
		// Construct an empty sequence.
		head_ptr = NULL;
		many_nodes = 0;
	}

	template <class Item>
	sequence<Item>::sequence(const sequence& source)
		//Uses node2.h
	{
		// Copy constructor, creates a copy to the sequence. Pretty self explainitory.
		node<Item> *tail_ptr; // Needed for arguement of list_copy.

		list_copy(source.head_ptr, head_ptr, tail_ptr); // Calls function list_copy() to copy the values of source starting at source.head_ptr to copy sequence.
		many_nodes = source.many_nodes; // Assigns the value of many nodes for the copy to however many nodes were used in source. Copy should have the same number of nodes as the source.
	}

	template <class Item>
	sequence<Item>::~sequence()
		// Uses node2.h
	{
		// Sequence destructor. Destructs the object when it's no longer being used. Also pretty self explainitory.
		list_clear(head_ptr); // Calls function list_clear() using the value of head_ptr to clear the nodes starting at the first node.
		many_nodes = 0; // After function call, the number of nodes should be 0. So, many_nodes is assigned to 0.
	}

	template<class Item>
	void sequence<Item>::start()
	{
		// Makes the first item the current item.
		cursor = head_ptr; // Assigns the location pointed to by head_ptr to cursor so that cursor is at the start of the function.
	}

	template<class Item>
	void sequence<Item>::advance()
	{
		// Makes the next item in the list the current item.
		// If current item is already the last item, then there is no next current item.

		// Move cursor to the next item in the list.
		++cursor;
		precursor = cursor - 1;
	}

	template<class Item>
	void sequence<Item>::insert(const value_type & entry)
	{
		// Inserts a new copy of entry before the current item and makes it the new current item.
		// If there is no current item, then the entry is inserted at the front of the list.

		// Check if there is any items in the list.
		if (head_ptr == NULL)
		{
			// If head_ptr points to NULL, then there is no item in the list and the new entry should be inserted at the front of the list.
			list_head_insert(head_ptr, entry); // Calls the function list_head_insert() to insert the new entry at the location pointed to by the head_ptr.
			++many_nodes; // Increase many_nodes by one to keep track of how many items are in the list.
		}
		else
		{
			// Else, insert the new entry in the spot before the current item.

			// Ensure that precursor points to the spot before the current item (which is in the spot pointed at by cursor).
			precursor = cursor - 1;

			// Put the new entry in the list.
			list_insert(precursor, entry); // Calls the function list_insert to insert the new entry at the spot pointed at by precursor.

			++many_nodes; // After function call, the new entry should be in the list and the number of items (nodes) in the list should have increased by one.
		}
	}

	template<class Item>
	void sequence<Item>::attach(const value_type & entry)
	{
		// Inserts a new copy of entry after the current item and makes it the new current item.
		// If there is no current item, then the new entry is attached to the end of the list.

		// Check if there is a current item.
		if (cursor == NULL)
		{
			// If cursor is equal to NULL, then there is no current item.
			list_insert(cursor, entry); // Calls the function list_insert to insert a copy of entry onto the list.
			++many_nodes; // Increases the count of many_nodes by one to keep track of how many items there are in the list.
		}
		else
		{
			// Else, the copy of the new entry needs to be inserted after the current item.

			// Ensure that precursor points to the location after the current item.
			// I know this sounds funny, but that way we don't have to make a new pointer just for this.
			precursor = cursor + 1;

			// Insert the new copy of entry into the list.
			list_insert(precursor, entry); // Calls the function list_insert() to put the new item into the list using the location provided by precursor.
			++many_nodes; // After function call, there should be one more item in the list so increase many_nodes by one to keep track of how many items are now in the list.
		}
	}

	template<class Item>
	void sequence<Item>::remove_current()
	{
		// Removes the current item in the list.

		// Check if the current item is the first item in the list.
		if (cursor == head_ptr)
		{
			// If it is, then the old head pointer needs to be removed and the next item in the list made the new one.
			// Call list_head_remove() to do this.
			list_head_remove(head_ptr);
			--many_nodes; // Decrease many_nodes by one to keep track of how many items are in the list.
		}
		else
		{
			// Else, the current item needs to be romoved and the next item in the list made to be the new current item.

			// Ensure that precursor points to the location before the current item.
			// Precursor is needed because the funcion list_remove() uses precursor to remove the current item. For some weird reason. Not sure why tbh.
			precursor = cursor - 1;

			// Remove the current item from the list.
			list_remove(precursor); // Calls function list_remove using precursor to remove the current item from the list.
								// After call, there should be one less item in the list.
			--many_nodes; // Decrease many_nodes by one to keep track of how many items are in the list.
	}

	template<class Item>
	value_type sequence<Item>::current() const
	{

		return cursor->list(); // Returns the value pointed at by cursor back to the function call.
	}


}