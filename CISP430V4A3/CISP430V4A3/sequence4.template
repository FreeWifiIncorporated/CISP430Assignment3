// Lorin Zhang
// sequence4.template
// Template implementation file for sequence4.h

#include <cstdlib> // Provides NULL value
#include "node2.h" // Provides node template class
#include "sequence4.h" // sequence header file

namespace CISP430_A3
{

	// default constructor 
	template <class Item>
	sequence<Item>::sequence()
		// Uses cstdlib.
	{
		// Construct an empty sequence.
		head_ptr = NULL;
		tail_ptr = NULL;
		cursor = NULL;
		precursor = NULL;
		many_nodes = 0;
	}

	template <class Item>
	sequence<Item>::sequence(const sequence& source)
		//Uses node2.h
	{
		// Copy constructor, creates a copy to the sequence. Pretty self explanitory.
		list_copy(source.head_ptr, head_ptr, tail_ptr); // Calls function list_copy() to copy the values of source starting at source.head_ptr to copy sequence.
		many_nodes = source.many_nodes; // Assigns the value of many nodes for the copy to however many nodes were used in source. Copy should have the same number of nodes as the source.
		
		size_type sourceCursorIndex = 0; // declare an index to store the index of source's cursor
		node<Item>* cursorAddress = source.cursor; // copy the address of the cursor pointer to be checked against later
		node<Item>* tempSourceCursor = source.head_ptr; // copy the address of source's head_ptr so source can be iterated through without changing the const source
		while (cursorAddress != tempSourceCursor) // check when the node being pointed at is the same as source's cursor
		{
			tempSourceCursor = tempSourceCursor->link(); // assign the temp cursor pointer to the next node
			++sourceCursorIndex; // increase the cursor index by one
		}

		start(); // start the cursor at the beginning
		for (size_type i = 0; i < sourceCursorIndex; ++i)
		{
			advance(); // advance the cursor (and by extension the precursor) until it is at the same "index" as source's cursor
		}
	}

	// destructor 
	template <class Item>
	sequence<Item>::~sequence()
		// Uses node2.h
	{
		// Sequence destructor. Destructs the object when it's no longer being used. Also pretty self explainitory.
		list_clear(head_ptr); // Calls function list_clear() using the value of head_ptr to clear the nodes starting at the first node.
		many_nodes = 0; // After function call, the number of nodes should be 0. So, many_nodes is assigned to 0.
	}

	template<class Item>
	void sequence<Item>::start()
	{
		// Makes the first item the current item.
		cursor = head_ptr; // Assigns the location pointed to by head_ptr to cursor so that cursor is at the start of the function.
	}

	template<class Item>
	void sequence<Item>::advance()
	{
		// Makes the next item in the list the current item.
		// If current item is already the last item, then there is no next current item.

		// Move cursor to the next item in the list.
		precursor = cursor;
		cursor = precursor->link();

	}

	template<class Item>
	void sequence<Item>::insert(const value_type & entry)
	{
		// Inserts a new copy of entry before the current item and makes it the new current item.
		// If there is no current item, then the entry is inserted at the front of the list.

		// Check if there is any items in the list.

		if (head_ptr == NULL)
		{
				// If head_ptr points to NULL, then there is no item in the list and the new entry should be inserted at the front of the list.
			list_head_insert(head_ptr, entry); // Calls the function list_head_insert() to insert the new entry at the location pointed to by the head_ptr.
			tail_ptr = head_ptr;
			cursor = head_ptr;
			precursor = NULL;
		}
		else if (is_item() == false || cursor == head_ptr)
		{
				// Else, insert the new entry in the spot before the current item.

				// Put the new entry in the list.
			list_head_insert(head_ptr, entry); // Calls the function list_insert to insert the new entry at the spot pointed at by precursor.
			cursor = head_ptr;
			precursor = NULL;
		}
		else
		{
			// Else, insert after precursor and set cursor to the new item.

			list_insert(precursor, entry);
			cursor = precursor->link();
		}

		++many_nodes; // increase many nodes by one to account for another node being added in the linked list
	}

	template<class Item>
	void sequence<Item>::attach(const value_type & entry)
	{
		// Inserts a new copy of entry after the current item and makes it the new current item.
		// If there is no current item, then the new entry is attached to the end of the list.

		// Check if there is a current item.
		// If cursor does not currently point at an item, then need to determine there is anything in the list or if cursor has moved past the tail_ptr (the last item in the list).
		if (head_ptr == NULL)
		{
			// If head_ptr is equal to NULL, then there is no item in the list yet since head_ptr always points to the first item in the list.

			list_head_insert(head_ptr, entry); // Calls the function list_insert to insert a copy of entry onto the list.
			cursor = head_ptr; // Cursor points to current item, head_ptr currently points to the only item in the list. So, point cursor to head_ptr.
			tail_ptr = cursor; // tail_ptr points to the last item in the list and cursor now points to the only item in the list so cursor also points to last item in list.
							   // Point tail_ptr at cursor.
		}
		else if (!is_item() || cursor == tail_ptr)
		{
			// Else if cursor points to a position after tail_ptr (the last item in the list)
			// then copy of the new entry needs to be inserted at the end of the list

			// Ensure that we are using the right position.
			precursor = cursor; // Sets precursor to the spot before NULL.

			list_insert(tail_ptr, entry); // Calls list_insert to insert a copy of the new entry at the spot pointed to by precursor.

			// After call, tail_ptr needs to point at the new item in the list which is pointed to by precursor.
			tail_ptr = tail_ptr->link();// tail_ptr now points to the last item in the list.
			cursor = tail_ptr; // cursor now points to the new current item on the list, which is the last item in the list.

		}
		else
		{
			// Elsee, if there is a current item, then a copy of the new entry must be inserted after the current item.

			list_insert(cursor, entry);
			precursor = cursor;
			cursor = precursor->link();
		}

		++many_nodes; // Increases the count of how many items there are in the list.
	}

	// assignment operator overload function
	template<class Item>
	void sequence<Item>::operator=(const sequence & source)
	{
		// Overloads the assignment operator so that it can be used to assign values from one sequence to another.
		
		// If the current object is the same object as what source is pointing to then return
		if (this == &source)
		{
			return;
		}

		list_clear(head_ptr); // delete the linked list currently pointed at by the sequence object and release the memory
		many_nodes = 0; // set the amount of nodes to 0

		list_copy(source.head_ptr, head_ptr, tail_ptr); // copy the content of source's linked list to a new linked list
		many_nodes = source.many_nodes; // set the amount of nodes to the amount source had

		size_type sourceCursorIndex = 0; // declare an index to store the index of source's cursor
		node<Item>* cursorAddress = source.cursor; // copy the address of the cursor pointer to be checked against later
		node<Item>* tempSourceCursor = source.head_ptr; // copy the address of source's head_ptr so source can be iterated through without changing the const source
		while (cursorAddress != tempSourceCursor) // check when the node being pointed at is the same as source's cursor
		{
			tempSourceCursor = tempSourceCursor->link(); // assign the temp cursor pointer to the next node
			++sourceCursorIndex; // increase the cursor index by one
		}

		start(); // start the cursor at the beginning
		for (size_type i = 0; i < sourceCursorIndex; ++i)
		{
			advance(); // advance the cursor (and by extension the precursor) until it is at the same "index" as source's cursor
		}
	}

	template<class Item>
	void sequence<Item>::remove_current()
	{
		// Removes the current item in the list.

		// Check if the current item is the first item in the list.
		if (cursor == head_ptr)
		{
			// If it is, then the old head pointer needs to be removed and the next item in the list made the new one.
			// Call list_head_remove() to do this.
			list_head_remove(head_ptr);
			cursor = head_ptr;
		}
		else
		{
			// Else, the current item needs to be romoved and the next item in the list made to be the new current item.

			// Remove the current item from the list.
			list_remove(precursor); // Calls function list_remove using precursor to remove the current item from the list.
									// After call, there should be one less item in the list.
			cursor = precursor->link();

		}

		--many_nodes; // Decreases the count of how many items there are in the list.
	}

	// get the current value of cucrsor
	template<class Item>
	Item sequence<Item>::current() const
	{
		return cursor->data(); // Returns the value pointed at by cursor back to the function call.
	}


}